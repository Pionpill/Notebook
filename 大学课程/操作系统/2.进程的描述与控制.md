# **进程描述与控制**

## **前趋图与程序执行**
> <big> 前趋图与程序执行 </big>
- 前趋图
  - 描述：前一个做完，才到后一个做、禁止循环
- 顺序执行
  - 描述：一个跟一个
  - 特征：顺序、封闭（独占资源）、可再现
- 并发执行
  - 描述：互不依赖才能并发执行
  - 特征：间断、失去封闭、不可再现

## **进程的描述**
> <big> 进程的定义和特征 </big>
- 进程实体：程序段、相关的数据段和PCB
- 定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
- 特征：动态、并发、独立、异步

> <big> 进程的基本状态及转换 </big>
- 进程的三基态：就绪（只欠CPU）、执行、阻塞（因故无法继续执行）
- 三态转换：如图
- 新增两态：创建状态、终止状态
- 五态转换：如图

> <big> 挂起操作和进程状态的转换 </big>
- 挂起原因：终端用户需要、父进程请求、负荷调节、操作系统需要
- 引入挂起后的三态转换：如图
- 引入挂起后的五态转换：如图

> <big> 进程管理中的数据结构 </big>
- 用于管理控制的数据结构：每个资源、进程都有一个数据结构用于表征实体——资源信息表、进程信息表，包括：标识、描述、状态等和一批指针，通过指针能够链接成队列，便于查找
分类：内存表、设备表、文件表、进程表
- PCB的作用：作为独立运行基本单位的标识、能实现间断运行、提供进程管理所需的信息、实现与其他进程的同步与通信
- PCB的信息：进程标识符（内外部）、处理机状态、进程调度信息、进程控制信息
- PCB组织方式：线性方式、链接方式、索引方式


## **进程控制**
> <big> 操作系统内核 </big>
- 描述：常驻内存的模块
- 目的：保护软件、提高OS运行效率
- 系统态、管态、内核态：高特权、访问所有寄存器.存储区、传统OS都在系统态运行
- 用户态、目态：低特权、执行指定指令.访问指定寄存器和存储区
- 支撑功能：中断处理、时钟管理、原语操作
- 资源管理功能：进程管理、存储器管理、设备管理

> <big> 进程的创建 </big>
- 层次结构：UNIX有父子关系，Windows只有控制与被控制关系
- 进程图：描述家庭关系的图
- 引起创建进程的事件：用户登录、作业调度、提供服务（譬如打印）、应用请求
- 进程的创建：申请空白PCB、分配物理.逻辑资源、初始化PCB、如果能插入就绪，就插

> <big> 进程的终止 </big>
- 引起进程终止的事件：正常结束、异常结束、外界干预
- 进程的终止过程：根据标识符、终止执行.立即调度、子孙终止、资源归还、移出队列

> <big> 进程的阻塞与唤醒 </big>
- 引起进程阻塞和唤醒的事件：向系统请求共享资源失败、等待某操作完成、新数据尚未到达、等待新任务到达
进行阻塞过程：发生上述的某事件，就进入block过程，主动将状态改为阻塞，PCB插入阻塞队列（分类插入），处理机分配给另一就绪进程，切换，并保留被阻塞进程的处理机状态
进程唤醒过程：由释放资源的进程调用wakeup原语，即移出阻塞队列，合作/相关的进程中安排wakeup

> <big> 进程的挂起与激活 </big>
- 进程的挂起：活动→静止，进程正在执行，就转向调度程序重新调度
- 进程的激活过程：从外存调入active原语到内存，检查进程现行状态，静止→活动
- 抢占调度策略：静止就绪进程→就绪队列，比较当前进程优先度，有机会立即剥夺当前进程运行

## **进程同步**
> <big> 进程同步的基本概念 </big>
- 描述：能够并发、改善利用率、提高吞吐量、但使系统复杂
- 制约关系：间接相互制约关系、直接相互制约关系
- 间接相互制约关系：互斥共享
- 直接相互制约关系：合作共享，异步性要做好
- 临界资源：生产者-消费者问题
- 临界区、：进入区、临界区、退出区、剩余区
- 同步机制应遵循的规则：空闲让进、忙则等待、有限等待、让权等待

> <big> 硬件同步机制 </big>
- 关中断：缺点多：滥用关中断.造成严重后果、关中断时间过长、不适用于多CPU系统（因为一个处理器关中断并不能防止进程在其他处理器上执行相同的临界段代码）
- Test-and-Set：不断测试lock，如果是FALSE，就进入临界区，并lock == TRUE；否则测试到TS(s) == TRUE
- Swap指令：一直等，直到key == TRUE
- 但以上都不符合“让权等待”原则

> <big> 信号量机制 </big>
- 整形信号量：S≤0，就一直等，直到释放互斥资源
- 记录型信号量：整形信号量不符合“让权等待”原则。如果有资源，就分配，如果无，就插入阻塞队列；释放资源，如果有等待，就激活
- AND型信号量：一口气全分配
- 信号量集：有多个信号量（S信号量,至少要t个,每次分配d个）

> <big> 信号量的应用 </big>
- 利用信号量实现进程互斥：mutex=(-1,0,1）=（无，一临一阻队， 一临一信队）
- 利用信号量实现前趋关系：需要的信号量被占用了，就这样实现

> <big> 管程机制 </big>
- 描述：为解决信号量机制分散、容易死锁的问题，发明新同步工具——管程
- 定义：定义一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据
- 组成：管程名称、数据结构的说明、对数据结构进行操作的过程、初始化的语句
- 组成：管程名称、数据结构的说明、对数据结构进行操作的过程、初始化的语句
- 管程与进程不同：都有数据结构，一个公.一个私、管程操作同步.初始化.进程顺序执行、管程为解决互斥资源.进程实现并发性、进程调用管程.进程主动.管程被动、管程不能并发.进程能并发、管程是OS的一个资源管理模块.进程有动态性
- 条件变量：增加一个条件变量，万一发生意外，在管程中被挂起或被阻塞，下一个进程都可以继续执行

## **经典进程的同步问题**
> <big> 生产者-消费者问题 </big>
- 记录型信号量解决：如果缓冲区空，而且能够获取信号量，就投放产品；如果缓冲区有产品，而且能够获取信号量，就消费
- AND信号量解决：一口气全分配
- 管程解决：利用管程只有一个进程能够使用的属性

> <big> 哲学家进餐问题 </big>
- 记录型信号量解决：先拿左.后那右、先放左.后放右
- 解决死锁：最多4人取筷子、先检查.有左右筷子才能取、奇左右.偶右左
- AND信号量解决：一口气全分配

> <big> 读者-写者问题 </big>
- 描述：可以多读一、一旦开始写.就不能读或写
- 记录型信号量解决：
  - 读操作：等rmutex就是为了改readcount→无人读？看看是否在写.等wmutex→readcount++→自增完成.rmutex还你→读读读→等rmutex为了自减readcount→无人读？可以写了.还你wmutex
  - 写操作：等wmutex.即无读无写→写完.还你wmutex
- 利用信号量集机制
  - 读：限制reader个数→如果mx是1.就读→最后释放一个reader个数
  - 写：如果mx是1.并且读者数为0.就写→写完释放mx

> <big> 进程通信 </big>
- 进程通信类型
  - 共享存储器系统：某些数据结构和共享存储区、管道通信系统、消息传递系统、C-S系统
- 消息传递通信的实现方式
  - 直接消息传递系统
    - 直接通信原语：对称寻址方式、非对称寻址方式
    - 消息格式：较短的减少系统处理和存储的开销、较长可以方便
    - 进程同步方式：发塞收塞（进程间紧密同步.无缓冲）、发通收塞（平常状态）、发通收通（发生某事件无法继续运行）、（无发塞收通）
    - 通信链路：用“建立连接”原语建立通信链路.用完拆、用“发送命令”原语建立链路，还分单向和双向
  - 信箱通信（间接）
    - 定义：是数据结构.分信箱头和信箱体
    - 原语：创建和撤销. 发送和接收
    - 类型：私用、公用（操作系统创建）、共享（进程创建）
    - 进程之间的关系：一对一、多对一、一对多、多对多
- 直接消息传递系统实例
  - 消息缓冲队列通信机制中的数据结构：利用数据结构式消息缓冲区、在PCB增加有关通信的数据项
原语：设置发送区、申请PCB(B)的缓冲区i、复制到缓冲区、插入消息队列、移出消息队列、复制到接收区、释放缓冲区

## **线程的基本概念**
> <big> 线程的引入 </big>
- 描述：就是为了提高程序并发执行的程度
- 进程的两个基本属性：
  - 进程是一个可拥有资源的独立单位、进程同时是一个可独立调度和分派的基本单位
进程并发执行所需的时空开销：
  - 创建进程、撤销进程、进程切换
  - 线程——作为调度和分派的基本单位：线程轻装上阵

> <big> 线程与进程比较 </big>
- 调度的基本单位：线程是调度和分派的基本单位、跨进程，会切换进程
- 并发性：线程的合作.能够并发
- 拥有资源：有TCB.但只是必不可少、保证独立运行的资源
- 独立性：同一进程的不同线程共享进程的内存地址空间和资源
- 系统开销：因为轻装.所以减少开销、提升速度
- 支持多处理机系统：对多线程进程，多个线程可以分配到多个处理机上

> <big> 线程的状态和线程控制块 </big>
- 线程运行的三个状态：和进程一样
- 线程控制块TCB：
  - 标识符、一组寄存器、运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针
- 多线程OS中的进程属性：
  - 进程是可拥有资源的基本单位、多个线程可并发执行、进程已不是可执行的实体

## **线程的实现**
> <big> 线程的实现方式 </big>
- 内核支持线程KLT
    - 优点：内核调度同一进程多个线程并行执行、一个线程阻塞.其他线程占有处理机、支持小数据结构和堆栈.切换较快开销小、内核本身采用多线程技术.提高系统执行速度和效率
- 用户级线程ULT：
  - 优点：无需内核.节省模式切换的开销、调度算法进程专用、与OS无关.甚至可以在操作系统平台实现 
  - 缺点：一个线程阻塞.同进程的其他线程都会塞、只有一个CPU.只有一个线程能执行、按进程分配.不公平
- 组合方式
  - 多对一模型：优点：开销小、缺点：一塞进程全塞、只有一线程访问内核、多线程不能同时在多个处理机上运行
  - 一对一模型：一个用户级线程映射到一个内核支持线程
  - 多对多模型：一对一和多对一的结合

> <big> 线程的实现 </big>
- 内核支持线程的实现
  - 创建线程、保存信息、调度和切换线程、撤销线程、回收资源
- 用户级线程的实现
  - 运行时系统
    - 用于管理和控制线程的函数的集合，这些函数驻留用户空间.并作为用户级线程与内核之间的接口
  - 内核控制线程
    - 连接到LWP，连接到LWP的线程才能与内核通信

> <big> 线程的创建和终止 </big>
- 线程的创建：初始化线程、创建后返回线程标识符
- 线程的终止：终止线程用函数或系统调用终止操作.但有些线程被建立就会一直执行。大多数OS，线程被中止后并不立即释放所占资源，只有“其他线程”执行分离函数才会分离资源，才能被其他线程利用。虽然未释放的资源也可以被其他线程使用，但要有个“等待线程终止”的连接命令作保险.否则一直阻塞
