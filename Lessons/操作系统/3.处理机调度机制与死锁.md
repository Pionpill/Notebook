<link href=style.css rel=stylesheet>

# **处理机调度与死锁**

## **处理机调度的层次**
> 处理机调度层次
- 描述：作业可能要经历多级处理机调度
- 高级调度（长程调度/作业调度）
  - 调度对象：作业
  - <span class=imp>功能</span>：
    - 根据某种算法，将后备队列中的某些作业调入内存，为它们创建进程、分配必要资源，并放入就绪队列
  - 主要存在于多道批处理系统，分时和实时系统不设置高级调度
  - 作业：通常的程序、数据和作业说明书
  - 作业控制块 JCB：保存了系统对作业进行管理和调度所需的全部信息
- 低级调度（进程调度/短程调度）
  - 调度对象：进程
  - <span class=imp>功能</span>：
    - 根据某种算法，决定就绪队列中的哪个进程应获得处理机，并将处理机分配给该进程
  - 进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的 OS 中，都必须配置这级调度
- 中级调度（内存调度）
  - 对象:进程，暂时不能运行的进程、把这些进程调到外存.设为挂起状态、一有条件.稍微有空就变为就绪状态
  - <span class=imp>功能</span>:
    - 换出： 将那些暂时不能运行的进程，调至外存等待（挂起）
    - 换入： 当条件具备时，再将它们重新调入内存，修改为就绪状态
  - 目的： 提高内存利用率和系统吞吐量
  - 分级按运行频率划分
  
> 进程调度方式
  - 非抢占方式
    - 实现简单，系统开销小，适用于大多数的批处理系统环境
    - 但它难以满足紧急任务的要求——立即执行，因而可能造成难以预料的后果
  - 抢占方式
    - 优点：可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是能满足对响应时间有着较严格要求的实时任务的需求
    - 但抢占方式比非抢占方式调度所需付出的开销较大
  
> 进程调度原则
  - 优先权原则、段作业（进程）优先原则、时间片原则
    - 面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则
    - 面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用

> 调度队列模型
  - 仅有进程调度的调度队列模型
  - 具有高级和低级调度的调度队列模型
  - 同时具有三级调度的调度队列模型


## 调度算法
> 先来先服务调度算法 【FCFS-First Come First Served】
  - 思想：
    - 从队列中选择最先进入的作业或进程
    - 非抢占式
  - 适用范围
    - 作业调度：从后备队列中选择最先进入的作业，创建PCB，分配资源，加入就绪队列
    - 进程调度：从就绪队列中选择最先进入的进程，分配CPU，使之运行
  - 优点
    - 简单、易于实现
    - 实际中经常把它与其他调度算法结合使用
  - 缺点
    - 平均等待时间长
    - 短进程需要等待先进入的长进程释放CPU
  - 图示  
    <img src=images/FCFS.png width=350px>
> 短作业(进程)优先调度算法 【SJF-Shortest Job First】
  - 思想：
    - 从队列中选择执行时间最短的进程分配CPU（也就是执行时间越短，优先级越高）
    - 抢占式/非抢占式
  - 适用范围
    - 既可用于作业调度，也可用于进程调度
  - 优点
    - 平均等待时间最小
  - 缺点
    - 对长作业非常不利，可能出现饥饿现象
    - 必须预知作业的运行时间（采用近似替代的方法，用历史执行时间进行预测）
  - 图示  
    <img src=images/SJF.png width=350px>
  - 抢占式SJF 与 非抢占式SJF
    <img src=images/SJF2.png width=700px>
    - 抢占与非抢占的区别就是：这一秒，如果有新到达的进程，它的运行时间比当前CPU正在运行的进程  
> 优先级调度算法 【PSA-Priority-Scheduling Algorithm】
  - 思想：
    - 基于作业的紧迫程度，由外部赋予作业相应的优先级
    - 每个进程关联一个优先级（数字），从队列中选择优先级最高的进程分配CPU
    - 具有相同优先级的进程按照 FCFS 顺序调度
    - 抢占式 / 非抢占式
  - 适用范围
    - 既可用于作业调度，也可用于进程调度
  - 图示  
    <img src=images/PSA.png width=350px>
  - 联系
    - SJF 和 FCFS 都可看作优先级调度算法的特例
  - 抢占式PSA 与 非抢占式PSA
    - 非抢占式：一直运行，直到完成或发生某事件使它放弃处理机
    - 抢占式：如果出现另一个优先数比它高的进程，它就要立即停止
  - 缺点
    - 低优先级的进程或作业会产生饥饿现象
  - 解决办法
    - 解决办法：逐渐提高等待时间长的进程或作业的优先级（也就是动态优先级）
> 高响应比优先调度算法【HRRN-Highest Response Ratio Next】
  - 优化
    - FCFS只考虑等待时间，SJF只考虑运行时间
  - 思想：
    - 在优先级调度算法的基础上引入动态优先级
      $$\text{优先级}R_{p}=\frac{\text{等待时间+要求服务时间}}{\text{要求服务时间}}=\frac{\text{响应时间}}{\text{要求服务时间}}$$
> 时间片轮转（轮转调度）算法 【RR-Round Robin】
  - 思想：
    - 针对分时系统，将CPU时间划分成一个个的时间片（time slice），为就绪队列中的进程依次轮流分配一个时间片的CPU
  - 适用范围
    - 抢占式：进程调度
  - 实现
    - FIFO队列 + 定时器
  - 进程切换的两种情况
    - 一个时间片还没有用完，正在运行的作业便已经完成，则激活调度程序，在就绪队列中删除该进程，再调度队首的进程，为其分配时间片
    - 一个时间片用完了，中断处理程序被激活，如果进程尚未运行完毕，则将其送到就绪队列的末尾
  - 图示  
    <img src=images/RR.png width=350px>
  - 性能分析
    - 就绪队列中有n个进程且时间片为q，每个进程必须等待的CPU时间不超过(n-1)q个时间单元
    - RR算法性能依赖于时间片的大小
    - 时间片小，意味着会频繁地执行进程调度和上下文的切换，无疑会增加系统开销
    - 时间片大，意味着大多数进程都会在一个时间片内完成，RR算法就退化成了FCFS，就有了FCFS一样的缺点：周转时间长，短作业经常等待长作业
> 多级反馈队列调度算法 【MFQ-Multilevel Feedback Queue】
  - 思想：
    - 设置多个就绪队列
      - 第一队列的优先级最高，每个队列的优先级依次降低，不同队列中进程的执行时间片大小也不同，优先级越高的队列，时间片越小
    - 每个队列都采用 RR/FCFS 算法，允许进程在队列之间移动
      - 一个新进程进入内存后，首先将它放入第一队列的末尾，接受调度。如果在第一个时间片尚未完成，调度程序则将它转入第二队列的末尾等待调度，依次类推……当进程最后被降到最后一个队列后，便一直在该队列中按照RR算法运行。
      - 较低优先级队列中等待时间较长的进程将被转移到优先级更高的队列中
    - 不同队列之间采用优先级抢占调度
      - 仅当第一队列空闲时（也就是第一队列没进程需要调度了）才调度第二队列中的进程运行。但是如果CPU正在执行第二队列中的进程A，此时第一队列中忽然进入了新的进程B，那么CPU会立即把进程A放回第二队列末尾，然后处理进程B
  - 图示  
    <img src=images/MFQ.png width=350px>

## 实时调度
> 实现条件
  - 提供必要的信息
  - 系统处理能力强
  - 采用抢占式调度机制
  - 具有快速切换机制
> 分类
  - 非抢占式调度算法
    - 非抢占式轮转调度算法、非抢占式优先调度算法
  - 抢占式调度算法
    - 基于时钟中断的抢占式优先权调度算法
> 常用的几种实时调度算法
  - 最早截止时间优先算法 【EDF-Earliest Deadline First】
    - 根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。具有最早截止时间的任务排在队列的最前面。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行
  - 最低松弛度优先算法 【LLF-Least Laxity First】
    - 根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行

## 死锁概述
> 死锁的定义
  - 如果一组进程中的每一个进程都在等待只能由该组进程中的其它进程引发的事件，那么该组进程是死锁的
> 产生死锁的必要条件
  - 互斥条件
    - 进程对资源的使用是排他性的使用
    - 某资源只能由一个进程使用，其他进程需要使用只能等待
  - 请求和保持（占有并等待）条件
    - 进程至少保持一个资源，又提出新的资源请求
    - 新资源被占用，请求被阻塞
    - 被阻塞的进程不释放自己保持的资源
  - 不可抢占条件
    - 进程已获得的资源在未使用完之前不得被抢占
    - 获得的资源只能由进程自身释放
  - 循环等待条件
    - 发生死锁时，必然存在一个“进程——资源循环链”

## **预防死锁**
> 条件破坏
  - 因为互斥条件是必须的，不仅不能改变，还应该加以保证。因此只能破坏后三个条件
> 破坏请求和保持条件
  - 破坏“请求”条件（预先静态分配法）
    - 方法
      - 每个进程执行之前，必须一次性地申请其在整个运行期间所需的全部资源，全部申请到了才能运行。这样它在整个运行过程中便不会再提出资源请求，从而破坏了“请求”条件。
    - 缺点
      - 资源利用率很低：有些资源可能在最后才会用到，它却一直占用了那么久
      - 进程可能出现饥饿现象：可能由于个别资源别其他进程占用而导致某进程迟迟不能开始
  - 破坏“保持”条件
    - 每个进程提出申请资源前必须释放已占有的一切资源
> 破坏非抢占条件
  - 走不通就放弃自己的已有资源造福别人
    - 进程 Pi 申请 Rj 类资源时，检查 Rj 中有无可用资源：有则分配给 Pi ；否则将 Pi 占有的资源全部释放而进入等待状态（Pi等待其原占有的所有资源和申请的资源）
  - 走不通先去抢别人的（前提是别人也走不通），抢不到就放弃自己的
    - 当进程 Pi 申请 Rj 类型的资源时检查 Rj 中有无可用资源：有则分配给 Pi ；否则检查已获得 Rj 类资源的进程 Pk ，若 Pk 处于等待资源状态，则抢占 Pk 的 Rj 类资源并分配给 Pi，若 Pk 不处于等待资源状态，则置 Pi 于等待资源状态（此时Pi原已占有的资源可能被抢占）
  - 缺陷
    - 有的资源是不可抢占资源，比如打印机，被抢占后可能导致前一阶段的工作失效
    - 延长了周转时间，降低了系统吞吐量，增加了系统开销：因为某些进程的执行可能会被无限推迟
> 破坏循环等待条件（有序资源使用法）
  - 给系统中的所有资源类型进行排序编号
    - 每个进程只能按递增顺序申请资源，即进程申请了序号为 8 的资源后，下次只能申请序号为 9 或以上资源
    - 如果进程需要同一资源类型的多个实例（也就是序号相同的资源），则必须对它们一起进行申请
    - 如果进程后面又想申请序号低的资源（比如5），那就必须把现在拥有的序号为5及其以上的资源全部释放
  - 为什么这种规则可以破坏循环等待条件？
    - 核心：每个进程只能按递增顺序申请资源
    - 因此每个时刻总有一个进程占据了较高序号的资源，那么它后面继续申请的资源一定是空闲的，这就保证了进程是可以一直向前推进的
  - 优点
    - 与前两种策略相比，其资源利用率和系统吞吐量都有明显的改善
  - 缺点
    - 序号必须相对稳定，这就限制了新设备的增加
    - 如果作业使用各类资源的顺序与系统规定的递增顺序不符合的话，就会造成资源的浪费
    - 按规定次序申请资源的方法会限制用户简单、自主地编程

## 避免死锁
> 安全状态与不安全状态
  - 系统处于安全状态时，就可避免死锁；处于不安全状态时，可能发生死锁
  - 安全状态
    - 是指系统此时能找到一个进程的序列<P1,P2,P3…Pn>，只要按照此顺序为其分配资源，就能使每个进程都能顺利完成。如果存在一个安全序列，那么系统则处于安全状态，否则就处于不安全状态
  - 在避免死锁方法中，允许进程动态地申请资源，但是系统在分配资源之间，会先计算此次资源分配的安全性，安全的话才分配，不安全的话便令进程等待
> 系统安全状态
  - 系统进程按某一顺序能顺利完成，则称系统安全
> 银行家算法
  - 算法逻辑
    - 首先检查进程申请的各资源数量是否比它自己所需要的还多，是的话，出错，不分配
    - 否则检查进程申请的各资源数量是否比系统可以提供的还多，是的话，分配失败，等待
    - 否则假设可以为其分配，修改 Pi 的相关矩阵
      - Available = Available – Request[i]      //系统资源减少
      - Allocation[i] = Allocationi + Request[i]     //进程已分配的增加
      - Need[i]= Need[i] – Request[i]       //进程需要的减少
    - 然后进行安全性检查
      - Work 矩阵是检查算法中的一个代替 Available 的临时矩阵
      - 当进程 Pi 执行完之后，它会释放资源，那么此时 Work = Work（原来系统剩余） + Allocation（Pi释放的）
  - 例题  
    <img src=images/银行家算法1.png width=500px>  
    <img src=images/银行家算法2.jpg width=500px>

## 死锁的检测与解除
> 死锁的检测
  - 资源分配图的方法
    - 适用情况
      - 每个资源类型只包含一个实例时可以使用
    - 判断方法
      - 需求边 P2→ R2，表示进程 P2 在将来某个时刻会申请资源 R2，用虚线表示，如下面左图。
      - 判断 P2 的这个申请是否会造成不安全状态
      - 假设已经将资源分配给 P2，所以要把 P2→ R2 的需求边转换为 R2→ P2 的分配边，如下面右图。
      - 此时发现整个图中出现了环，所以现在进行 R2→ P2 的分配是不安全的。
        <img src=images/资源分配图算法.png width=400px>
> 死锁的解除
  - 终止进程的方法
    - 终止所有死锁进程
      - 是最简单的方法，终止所有死锁进程后，死锁自然就解除了
      - 缺点：代价可能会很大：有些快要结束的进程一旦被终止，可谓是“功亏一篑”
    - 逐个终止进程，直至死锁解除
  - 资源抢占的方法
    - 事先规定好进程被抢占的顺序以使代价最小（要让各进程有限的被选为“牺牲品”，否则某些经常被强占的进程会发生“饥饿”现象。）
    - 发生死锁时，选择一个“牺牲品”，抢占它的资源给其它进程
    - 然后将这个“牺牲品”进程回滚到过去的某个安全状态